%class-name Compiler
%filenames compiler
%parsefun-source compiler_bisoncpp_generated.cc
%scanner scanner.h
%baseclass-preinclude "bfxfunction.h"
%tag-mismatches on

%polymorphic    INT:                    int;
                CHAR:                   char;
                STRING:                 std::string;
                ARRAY_ELEMENT:          std::pair<std::string, Instruction>;
                INSTRUCTION:            Instruction;
                INSTRUCTION_LIST:       std::vector<Instruction>;
                DECLARATION:            std::pair<std::string, int>;
                DECLARATION_LIST:       std::vector<std::pair<std::string, int>>;
                PARAMETER:              BFXFunction::Parameter;
                PARAMETER_LIST:         std::vector<BFXFunction::Parameter>;
                SWITCH_CASE:            std::pair<Instruction, Instruction>;
                CASE_LIST:              std::vector<std::pair<Instruction, Instruction>>;
                BFX_FUNCTION:           BFXFunction;

%expect 0

// Keywords
%token LET FUNCTION GLOBAL INLINE_BF MOVE_PTR INCLUDE SIZEOF FOR IF WHILE CONST SWITCH CASE DEFAULT INC DEC

%nonassoc then
%nonassoc ELSE

// Operators
%right '=' ADD SUB MUL MOD DIV DIVMOD MODDIV
%left OR
%left AND
%left EQ NE
%left '<' '>' LE GE
%left '+' '-'
%left '*' '/' '%'
%right postInc postDec  '!' unaryMinus
%left preInc preDec

%token <STRING> IDENT
%token <STRING> STR
%token <INT>    NUM
%token <CHAR>   CHR

%type <INSTRUCTION>         expression
%type <INSTRUCTION>         statement
%type <INSTRUCTION>         if_statement
%type <INSTRUCTION>         for_statement
%type <INSTRUCTION>         switch_statement
%type <CASE_LIST>           case_list
%type <SWITCH_CASE>         switch_case
%type <INSTRUCTION>         default_case
%type <INSTRUCTION>         variable
%type <DECLARATION>         variable_declaration
%type <DECLARATION>         variable_specification
%type <DECLARATION_LIST>    variable_specification_list
%type <ARRAY_ELEMENT>       array_element
%type <INSTRUCTION>         constant_literal
%type <INSTRUCTION>         string_literal
%type <INSTRUCTION>         anonymous_array
%type <INSTRUCTION>         function_call
%type <INSTRUCTION>         scope_block
%type <INSTRUCTION>         code_body
%type <INSTRUCTION_LIST>    expression_list
%type <INSTRUCTION_LIST>    optional_expression_list
%type <PARAMETER>           parameter
%type <PARAMETER_LIST>      parameter_list
%type <PARAMETER_LIST>      optional_parameter_list
%type <BFX_FUNCTION>        function_header


%%

program:
    // empty
|
    program error
|
    program function_definition
|
    program global_variable_list
|
    program include_directive
|
    program const_definition
;

include_directive:
    INCLUDE STR
    {
        d_scanner.pushStream($2);
    }
;

function_definition:
    function_header scope_block
    {
        addFunction(($1).setBody($2));
    }
;

function_header:
    FUNCTION IDENT '(' optional_parameter_list ')'
    {
        $$ = BFXFunction($2, $4);
    }
|
    FUNCTION IDENT '=' IDENT '(' optional_parameter_list ')'
    {
        $$ = BFXFunction($4, $6);
        ($$).setReturnVariable($2);
    }
;

const_definition:
    CONST IDENT '=' NUM ';'
    {
        addConstant($2, $4);
    }
|
    CONST IDENT '=' CHR ';'
    {
        addConstant($2, $4);
    }
;

scope_block:
    '{' code_body '}'
    {
        $$ = $2;
    }
;

parameter:
    IDENT
    {
        $$ = BFXFunction::Parameter(
             $1,
             BFXFunction::ParameterType::Value
        );
    }
|
    '&' IDENT
    {
        $$ = BFXFunction::Parameter(
             $2,
             BFXFunction::ParameterType::Reference
        );
    }
;

parameter_list:
    parameter
    {
        auto ret = std::vector<BFXFunction::Parameter>();
        ret.push_back($1);
        $$ = ret;
    }
|
    parameter_list ',' parameter
    {
        ($1).push_back($3);
        $$ = $1;
    }
;

optional_parameter_list:
    parameter_list
|
    // empty
    {
        $$ = std::vector<BFXFunction::Parameter>();
    }
;

global_variable_list:
    GLOBAL variable_specification_list ';'
    {
        addGlobals($2);
    }
;

code_body:
    {
        $$ = Instruction([](){ return -1; });
    }
|
    code_body statement
    {
        $$ = instruction<&Compiler::mergeInstructions>($1, $2);
    }
;

statement:
    error ';' // continue parsing at the next statement
|
    ';'
    {
        $$ = instruction<&Compiler::statement>([](){ return -1; });
    }
|
    expression ';'
    {
        $$ = instruction<&Compiler::statement>($1);
    }
|
    scope_block
|
    INLINE_BF '(' STR ')' ';'
    {
        $$ = instruction<&Compiler::inlineBF>($3);
    }
|
    MOVE_PTR '(' IDENT ')' ';'
    {
        $$ = instruction<&Compiler::movePtr>($3);
    }
|
    for_statement
|
    if_statement
|
    while_statement
|
    switch_statement
;

expression:
    variable_declaration
    {
        $$ = instruction<&Compiler::declareVariable>(($1).first, ($1).second);
    }
|    
    variable
|
    '-' expression %prec unaryMinus
    {
        compilerError("Negative numbers are not supported.");
        $$ = []() { return -1; };
    }
|
    array_element
    {
        $$ = instruction<&Compiler::fetchElement>(
           ($1).first,
           ($1).second
        );
    }
|
    constant_literal
|
    string_literal
|
    anonymous_array
|
    function_call
|
    SIZEOF '(' IDENT ')'
    {
        $$ = instruction<&Compiler::sizeOfOperator>($3);
    }
|
    variable_declaration '=' expression
    {
        $$ = instruction<&Compiler::initializeExpression>(
                ($1).first,
                ($1).second,
                $3
             );
    }
|
    variable '=' expression
    {
        $$ = instruction<&Compiler::assign>($1, $3);
    }
|
    array_element '=' expression
    {
        $$ = instruction<&Compiler::assignElement>(
           ($1).first,
           ($1).second,
           $3
        );
    }
|
    '(' expression ')'
    {
        $$ = $2;
    }
|
    INC variable %prec preInc
    {
        $$ = instruction<&Compiler::preIncrement>($2);
    }
|
    DEC variable %prec preDec
    {
        $$ = instruction<&Compiler::preDecrement>($2);
    }
|
    variable INC %prec postInc
    {
        $$ = instruction<&Compiler::postIncrement>($1);
    }
|
    variable DEC %prec postDec
    {
        $$ = instruction<&Compiler::postDecrement>($1);
    }
|
    INC array_element %prec preInc
    {
        $$ = instruction<&Compiler::applyUnaryFunctionToElement>(
                ($2).first,
                ($2).second,
                &Compiler::preIncrement
            );
    }
|
    DEC array_element %prec preDec
    {
        $$ = instruction<&Compiler::applyUnaryFunctionToElement>(
                ($2).first,
                ($2).second,
                &Compiler::preDecrement
            );
    }
|
    array_element INC %prec postInc
    {
        $$ = instruction<&Compiler::applyUnaryFunctionToElement>(
                ($1).first,
                ($1).second,
                &Compiler::postIncrement
            );
    }
|
    array_element DEC %prec postDec
    {
        $$ = instruction<&Compiler::applyUnaryFunctionToElement>(
                ($1).first,
                ($1).second,
                &Compiler::postDecrement
            );
    }
|
    variable ADD expression
    {
        $$ = instruction<&Compiler::addTo>($1, $3);
    }
|
    array_element ADD expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                &Compiler::addTo
           );
    }
|
    expression '+' expression
    {
        $$ = instruction<&Compiler::add>($1, $3);
    }
|
    variable SUB expression
    {
        $$ = instruction<&Compiler::subtractFrom>($1, $3);
    }
|
    array_element SUB expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                &Compiler::subtractFrom
           );
    }
|
    expression '-' expression
    {
        $$ = instruction<&Compiler::subtract>($1, $3);
    }
|
    variable MUL expression
    {
        $$ = instruction<&Compiler::multiplyBy>($1, $3);
    }
|
    array_element MUL expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                Compiler::BinaryFunction(&Compiler::multiplyBy)
           );
    }
|
    expression '*' expression
    {
        $$ = instruction<&Compiler::multiply>($1, $3);
    }
|
    variable DIV expression
    {
        $$ = instruction<&Compiler::divideBy>($1, $3);
    }
|
    array_element DIV expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                Compiler::BinaryFunction(&Compiler::divideBy)
            );
    }
|
    expression '/' expression
    {
        $$ = instruction<&Compiler::divide>($1, $3);
    }
|
    variable MOD expression
    {
        $$ = instruction<&Compiler::moduloBy>($1, $3);
    }
|
    array_element MOD expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                Compiler::BinaryFunction(&Compiler::moduloBy)
            );
    }
|
    variable DIVMOD expression
    {
        $$ = instruction<&Compiler::divMod>($1, $3);
    }
|
    array_element DIVMOD expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                Compiler::BinaryFunction(&Compiler::divMod)
            );
    }
|
    variable MODDIV expression
    {
        $$ = instruction<&Compiler::modDiv>($1, $3);
    }
|
    array_element MODDIV expression
    {
        $$ = instruction<&Compiler::applyBinaryFunctionToElement>(
                ($1).first,
                ($1).second,
                $3,
                Compiler::BinaryFunction(&Compiler::modDiv)
            );
    }
|
    expression '%' expression
    {
        $$ = instruction<&Compiler::modulo>($1, $3);
    }
|
    expression '<' expression
    {
        $$ = instruction<&Compiler::less>($1, $3);
    }
|
    expression '>' expression
    {
        $$ = instruction<&Compiler::greater>($1, $3);
    }
|
    expression LE expression
    {
        $$ = instruction<&Compiler::lessOrEqual>($1, $3);
    }
|
    expression GE expression
    {
        $$ = instruction<&Compiler::greaterOrEqual>($1, $3);
    }
|
    expression NE expression
    {
        $$ = instruction<&Compiler::notEqual>($1, $3);
    }
|
    expression EQ expression
    {
        $$ = instruction<&Compiler::equal>($1, $3);
    }
|
    '!' expression
    {
        $$ = instruction<&Compiler::logicalNot>($2);
    }
|
    expression AND expression
    {
        $$ = instruction<&Compiler::logicalAnd>($1, $3);
    }
|
    expression OR expression
    {
        $$ = instruction<&Compiler::logicalOr>($1, $3);
    }
;

for_statement:
    FOR '(' expression ';' expression ';' expression ')' statement
    {
        $$ = instruction<&Compiler::forStatement>($3, $5, $7, $9);
    }
;

if_statement:
    IF '(' expression ')' statement
    {
        $$ = instruction<&Compiler::ifStatement>($3, $5, Instruction([](){ return -1; }));
    }
|
    IF '(' expression ')' statement ELSE statement %prec then
    {
        $$ = instruction<&Compiler::ifStatement>($3, $5, $7);    
    }
;

while_statement:
    WHILE '(' expression ')' statement
    {
        $$ = instruction<&Compiler::whileStatement>($3, $5);
    }
;

switch_statement:
    SWITCH '(' expression ')' '{' case_list '}'
    {
        $$ = instruction<&Compiler::switchStatement>($3, $6, [](){ return -1; });
    }
|
    SWITCH '(' expression ')' '{' case_list default_case '}'
    {
        $$ = instruction<&Compiler::switchStatement>($3, $6, $7);
    } 

;

case_list:
    switch_case
    {
        $$ = std::vector<std::pair<Instruction, Instruction>>();
        ($$).push_back($1);
    }
|
    case_list switch_case
    {
        ($1).push_back($2);
        $$ = $1;
    }
;

switch_case:
    CASE expression ':' statement
    {
        $$ = std::make_pair($2, $4);
    }
;

default_case:
    DEFAULT ':' statement
    {
        $$ = $3;
    }
;    

variable_declaration:
    LET variable_specification
    {
        $$ = $2;
    }
;

variable_specification:
    IDENT
    {
        $$ = std::pair<std::string, int>($1, 1);
    }
|
    '[' ']' IDENT
    {
        $$ = std::pair<std::string, int>($3, -1);
    }
|
    '[' NUM ']' IDENT
    {
        $$ = std::pair<std::string, int>($4, $2);
    }
|
    '[' IDENT ']' IDENT
    {
        $$ = std::pair<std::string, int>($4, compileTimeConstant($2));
    }
;    


variable_specification_list:
    variable_specification
    {   
        $$ = std::vector<std::pair<std::string, int>>();
        ($$).push_back($1);
    }
|
    variable_specification_list ',' variable_specification
    {
        ($1).push_back($3);
        $$ = $1;
    }
;

variable:
    IDENT
    {
        $$ = instruction<&Compiler::fetch>($1);
    }
;

constant_literal:
    NUM
    {
        $$ = instruction<&Compiler::constVal>($1);
    }
|
    CHR
    {
        $$ = instruction<&Compiler::constVal>($1);
    }
;

expression_list:
    expression
    {
        $$ = std::vector<Instruction>{};
        ($$).push_back($1);
    }
|
    expression_list ',' expression
    {
        ($1).push_back($3);
        $$ = $1;
    }
;

optional_expression_list:
    // empty
    {
        $$ = std::vector<Instruction>{};
    }
|
    expression_list
;


array_element:
    IDENT '[' expression ']'
    {
        $$ = std::pair<std::string, Instruction>($1, $3);
    }
;

string_literal:
    STR
    {
        $$ = instruction<&Compiler::arrayFromString>($1);
    }
;

anonymous_array:
    '#' '(' expression_list ')'
    {
        $$ = instruction<&Compiler::arrayFromList>($3);
    }
|
    '#' '[' NUM ']'
    {
        $$ = instruction<&Compiler::arrayFromSizeStaticValue>($3, 0);
    }
|
    '#' '[' IDENT ']'
    {
        $$ = instruction<&Compiler::arrayFromSizeStaticValue>(
                compileTimeConstant($3),
                0
           );
    }
|
    '#' '[' NUM ',' expression ']'
    {
        $$ = instruction<&Compiler::arrayFromSizeDynamicValue>($3, $5);
    }
|
    '#' '[' IDENT ',' expression ']'
    {
        $$ = instruction<&Compiler::arrayFromSizeDynamicValue>(
                compileTimeConstant($3),
                $5
           );
    }
;

function_call:
    IDENT '(' optional_expression_list ')'
    {
       $$ = instruction<&Compiler::call>($1, $3);
    }
;