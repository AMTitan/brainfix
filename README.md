# Brainfix v2.0
This is a reboot of a little project I did as a student. BrainFix is a compiler that takes a C-style
language (although the syntax slowly evolved to something very close to Javascript for some reason) and compiles this
into [BrainF*ck](https://esolangs.org/wiki/Brainfuck), an esoteric programming language consisting of only 8 operations.

To run the resulting Brainf*ck code, you can use any third party utility that does the job. However, a simple
interpreter `bfint` is included in the project, which will be built along with the `bfx` compiler.

## Bisonc++ and Flexc++
The lexical scanner and parser that are used to parse the Brainfix language are generated by [Bisonc++](https://fbb-git.gitlab.io/bisoncpp/)
and [Flexc++](https://fbb-git.gitlab.io/flexcpp/) (not to be confused with bison++ and flex++). This software is readily available in the
Debian repositories, but not necessarily needed to build this project. The sourcefiles generated by these programs, based on the current grammar and lexer specifications, are included in the source-folder.

## Building
To build the project, simply cd into the src folder and call make:

```
cd src
make
```

To let bisonc++ and flexc++ regenerate the sourcecode for the scanner and parser, run

```
make regenerate
make
```

To copy the resulting binaries to `/usr/local/bin`, run as root:

```
make install
```

## Usage
### Using the `bfx` executable
Building the project results will produce the compiler executable `bfx`. The syntax for invoking the compiler can be inspected by running `bfx -h`:

```
$ bfx -h
Usage: bfx [options] [target(.bfx)]
Options:
-h                  Display this text.
-t [Type]           Specify the number of bytes per BF-cell, where [Type] is one of
                    int8, int16 and int32 (int8 by default).
-I [path to folder] Specify additional include-path.
                    This option may appear multiple times to specify multiple folders.
-O0                 Do NOT do any constant expression evaluation.
-O1                 Do constant expression evaluation (default).
-o [file, stdout]   Specify the output stream/file (default stdout).

Example: bfx -o program.bf -O1 -I ~/brainfix/std/ -t int16 program.bfx
```

### Using the `bfint` executable
To run the resulting BF, call the included interpreter or any other utility that was designed to run or compile BF. When using the included `bfint` interpreter, its syntax can be inspected by running `bfint -h`:

```
$ bfint -h
Usage: bfint [options] [target(.bf)]
Options:
-h                  Display this text.
-t [Type]           Specify the number of bytes per BF-cell, where [Type] is one of
                    int8, int16 and int32 (int8 by default).
-n [N]              Specify the number of cells (30,000 by default).
-o [file, stdout]   Specify the output stream (defaults to stdout).

Example: bfint -t int16 -o output.txt program.bf
```

### The type of a BrainF\*ck cell
The type of the BF cell that is assumed during compilation with `bfx` can be specified using the `-t` option and will specify the size of the integers on the BF tape. By default, this is a single byte (8-bits). Other options are `int16` and `int32`. All generated BF-algorithms work with any of these architectures, so changing the type will not result in different BF-code. It will, however, allow the compiler to issue a warning if numbers are used throughout the program that exceed the maximum value of a cell. The same flag can be specified to `bfint`. This will change the size of the integers that the interpreter is operating on. For example, executing the `+` operation on a cell with value 255 will result in overflow (and wrap around to 0) when the interpreter is invoked with `-t int8` but not when it's invoked with `-t int16`. 

### Constant Evaluation (`O0` vs `O1`)
By default (option `-O1`), the compiler will perform as many calculations as it can at compile-time. For instance, consider the following expression:

```javascript
let n = 3 + 4;
```
The value 7 will be stored internally, but no BF-code will be generated because the value of `n` is not used to do anything. However, when the compiler is called with the `O0`-flag, every operation is translated directly to BF-code. In case of the example above, this will result in the following operations:

1. Create a cell containing the number 3.
2. Create a cell containing the number 4.
3. Perform the addition algorithm on these cells.

For obvious reasons, running in `O0`-mode will lead to significantly larger output. For example, the 'Hello World'-example below, when run in `O0`-mode, results in a total of approximately 12,000 BF-operations. In the default `O1`-mode, it's less than 1,200 operations.

### Example: Hello World
Every programming language tutorial starts with a "Hello, World!" program of some sort. This is no exception:

```javascript
// File: hello.bfx
include "std.bfx"

function main()
{
    println("Hello, World!");
}
```
#### Comments
The program starts with an end-of-line comment (C-comment blocks between `/*` and `*/` are also allowed) and then
includes the IO-library which is included with this project. This exposes some basic IO-facilities the sourcefile.

#### `main`
Next, the main-function is defined. Every valid BFX-program should contain a `main` function which takes no arguments and does not return anything. The order in which the functions are defined in a BFX-file does not matter; the compiler will always try to find main and use this as the entrypoint.

#### Compiling
In `main()`, the function `println()` from the IO library is called to print the argument and a newline to the console. The IO library is part of the standard library, which is located in the `std` folder, which we have to pass as the include-path.

Let's compile this example (assuming `bfx` and `bfint` are in your PATH):

```
$ bfx -o hello.bf -I std/ hello.bfx
$ bfint hello.bf
Hello, World!
```

## Target Architecture
The compiler targets the canonical BrainF*ck machine, where cells are unsigned integers of the type specified as the argument to the `-t` flag. At the start of the program, it is assumed that all cells are zero-initialized and the pointer is pointing at cell 0. Furthermore, it is assumed that the tape-size is, for all intents and purposes, infinitely long. The produced BF consists of only the 8 classic BF-commands (no [extensions](https://esolangs.org/wiki/Extended_Brainfuck)):

| Command | Effect |
| --- | --- |
| `>` | Move pointer to the right. |
| `<` | Move pointer to the left. |
| `+` | Increase value pointed to by 1. |
| `-` | Decrease value pointed to by 1. |
| `[` | If current value is nonzero, continue. Otherwise, skip to matching `]` |
| `]` | If current value is zero, continue. Otherwise, go back to matching `[` |
| `.` | Output current byte to stdout |
| `,` | Read byte from stdin and store it in the current cell |


## Language
### Functions
A BrainFix program consists of a series of functions (one of which is called `main()`). Apart from global variable declarations, `const` declarations, user-defined types (structs) and file inclusion (more on those later), no other syntax is allowed at global scope. In other words: BF code is only generated in function-bodies.

A function without a return-value is defined like we saw in the 'Hello World' example and may take any number of parameters. For example:

```javascript
function foo(x, y, z)
{
    // body
}
```

When a function has a return-value, the syntax becomes:

```javascript
function ret = bar(x, y, z)
{
    // body --> must contain instantiation of 'ret' !
}
```

It does not matter where a function is defined with respect to the call:
```javascript
function foo()
{
    let x = 31;
    let y = 38;

    let nice = bar(x, y); // works, even if bar is defined below
}

function z = bar(x, y)
{
    let z = x + y; // return variable is instantiated here
}
```

#### Value and Reference Semantics
By default, all arguments are passed by value to a function: every argument is copied into the local scope of the function. Modifications to the arguments will therefore have no effect on the corresponding variables in the calling scope.

```javascript
function foo()
{
    let x = 2;
    bar(x);

    // x == 2, still
}

function bar(x)
{
    ++x;
}
```

However, BrainFix supports reference semantics as well. Parameters prefixed by `&` (like in C++) are passed by reference to the function. This will prevent the copy from taking place and will therefore be faster than passing it by value. However, it also introduces the possibility of subtle bugs, which is why it's not the default mode of operation.

```javascript

function foo()
{
    let x = 2;
    bar(x);

    // x == 3 now
}

function bar(&x)
{
    ++x;
}

```

#### Recursion
Unfortunately, recursion is not allowed in BrainFix. Most compilers implement function calls as jumps. However, this is not possible in BF code because there is no JMP instruction that allows us to jump to arbitrary places in the code. It should be possible in principle, but would be very hard to implement (and would probably require a lot more memory to accomodate the algorithms that could make it happen). Therefore, the compiler will throw an error when recursion is detected.

### Variable Declarations
New variables are declared using the `let` keyword and can from that point on only be accessed in the same scope; this includes the scope of `if`, `for` and `while` statements. At the declaration, the size (or type, see below) of the variable can be specified using square brackets. Variables declared without a size-specifier are allocated as having size 1. It's also possible to let the compiler deduce the size of the variable by adding empty brackets `[]` to the declaration. In this case, the variable must be initialized in the same statement in order for the compiler to know its size. After the declaration, only same-sized variables can be assigned to eachother, in which case the elements of the right-hand-side will be copied into the corresponding left-hand-side elements. There is one exception to this rule: an single value (size 1) can be assigned to an array as a means to initialize or refill the entire array with this value.

```javascript
function main()
{
    let x;                // size 1, not initialized
    let y = 2;            // size 1, initialized to 2
    let [10] array1;      // array of size 10, not initialized
    let [] str = "Hello"; // the size of str is deduced as 5 and initialized to "Hello"

    let [y] array2;       // ERROR: size of the array must be a number or const
    let [10] str2 = str;  // ERROR: size mismatch in assignment
    let [10] str3 = '0';  // OK: str3 is now a string of ten '0'-characters 
}
```

#### Initializing Variables
In the example above, we see how a string is used to initialize an array-variable. Other ways to initialize arrays all involve the `#` symbol to indicate an array-literal. In each of these cases, the size-specification can be empty, as the compiler is able to figure out the resulting size from its initializer.

```javascript
function main()
{
    let v1 = 1;
    let v2 = 2;
    let zVal = 42;

    let []x = #{v1, v2, 3, 4, 5}; // initializer-list
    let []y = #[5];               // 5 elements, all initialized to 0
    let []z = #[5, zVal];         // 5 elements, all initialized to 42

    let [zVal] arr;               // ERROR: size-specifier is not const
}
```
Size specifications must be known at compiletime; see the section on the `const` keyword below on how to define named compile-time constants.

#### Structs
In addition to declaring a variable by specifying its size, its type can be specified using the `struct` keyword and a previously defined struct-identifier. The definition of this `struct` must appear somewhere at global scope and can contain fields of any type, including arrays and other user defined types.

```javascript
struct Vec3
{
    x, y, z;
}; // semicolon is optional

struct Particle
{
    [struct Vec3] pos, [struct Vec3] vel; // nested structs
    id;                                   // fields specified over multiple lines
}; 

function print_vec3(&v)
{
    printc('(');
    printd(v.x); prints(", ");
    printd(v.y); prints(", ");
    printd(v.z); prints(")\n");
}

function main()
{
    let [struct Particle] p;

    p.id = 42;

    p.pos.x = 1;
    p.pos.y = 2;
    p.pos.z = 3;

    p.vel = Vec3{4, 5, 6};  // initializing using an anonymous Vec3 instance

    print_vec3(p.pos);
    print_vec3(p.vel);
}
```

#### Numbers
Only positive integers are supported; the compiler will throw an error on the use of the unary minus sign. A warning is issued when the program contains numbers that exceed the range of the specified type (e.g. 255 for the default `int8` type).

#### Indexing
Once an variable is declared (as an array), it can be indexed using the familiar index-operator `[]`. Elements can be both accessed and changed using this operator. When the index to the array can be resolved at compile-time, the compiler will check if it is withing bounds. Otherwise, it's up to the programmer to make sure the index is within the size of the indexed variable.

```javascript
function main()
{
    let [] arr = #(42, 69, 123);

    ++arr[0];     // 42  -> 43
    --arr[1];     // 69  -> 68
    arr[2] = 0;   // 123 -> 0

    arr[5] = 'x'; // Error will be reported!

    let n = scand();
    arr[n] = 'y'; // Anything may happen ...
}
```

#### Passing array-elements by reference
Operating on arrays using the index-operator usually works as expected. However, when an array-element is accessed through the index-operator (without operating on it) and passed to a function, the result of this expression might be temporary copy of the actual element, depending on whether the index was resolved at compile-time. If it was, the behaviour is as expected and an actual reference to the indexed element will be passed to the function. If however, the index cannot be resolved at compile-time, a temporary value containing a **copy** of the element is returned by the index operator. This is because the position of the BF-pointer has to be known at all times, even when the index is a runtime variable (for example determined by user-input). This leads to different semantics in both cases, which could be confusing. Consider the following example to illustrate the two cases:

```javascript
function modify(&x)
{
    ++x;
}

function main()
{
    let [5] arr = #{1, 2, 3, 4, 5};

    let n = 3;         // known at compiletime
    let m = scand();   // known at runtime

    ++arr[m];          // Works, even though m is a runtime variable

    modify(arr[n]);    // Fine: modified the 3rd element in-place
    modify(arr[m]);    // Fail: did not modify arr at all
}
```

To be safe, one should always pass the array and its index as seperate arguments to an element-modifying function, unless you're sure that it will only be called in a constant evaluation context. For example:

```javascript
function modify(&arr, &idx)
{
    ++arr[idx];
}

function main()
{
    let [5] arr = #{1, 2, 3, 4, 5};

    let m = scand();   // known at runtime
    modify(arr, m);    // works now
}
```

#### `sizeof()`
The `sizeof()` operator (it's not really a function, as it's a compiler intrinsic and not defined in terms of the BrainFix language itself) returns the size of a variable and can be used, for example, to loop over an array (more on control-flow in the relevant sections below). 

```javascript
function looper(arr)
{
    for (let i = 0; i != sizeof(arr); ++i)
        printd(arr[i]);
}
```

#### Constants
BrainFix provides a simple way to define constants in your program, using the `const` keyword. `const` declarations can only appear at global scope. Throughout the program, occurrences of the variable are replaced at compiletime by the literal value they've been assigned. This means that `const` variables can be used as array-sizes (which is their most common usecase):

```javascript
const SIZE = 10;

function main()
{
    let [] arr1 = #[SIZE, 42]; 
    let [] arr2 = #[SIZE, 69];

    arr1 = arr2; // guaranteed to work, sizes will always match
}
```

#### Global Variables
It's also possible to define runtime variables at global scope, using the `global` keyword. A global variable cannot be initialized in this declaration, so it's common to define an initializing function that's called from `main`. 

```javascript
include "std.bfx"

global x, y;      // single global variables
global [5]vec;    // global array of 5 cells

struct S
{
    x, y;
};

global [struct S] s;

function init()
{
    x = 42;
    y = 69;
    s = S{10, 20};
}

function main()
{
    init();
    
    printd(x);   endl();
    printd(y);   endl();
    printd(s.x); endl();
    printd(s.y); endl();
}
```

### Operators
The following operators are supported by BrainFix:

| Operator | Description |
| --- | --- |
| `++`  |  post- and pre-increment |
| `--`   |  post- and pre-decrement |
| `+`    |  add |
| `-`    |  subtract |
| `*`    |  multiply |
| `/`    |  divide |
| `%`    |  modulo |
| `+=`   |  add to left-hand-side (lhs), returns lhs |
| `-=`   |  subtract from lhs, returns lhs |
| `*=`   |  multiply lhs by rhs, returns lhs |
| `/=`   |  divide lhs by rhs, returns lhs |
| `%=`   |  assigns the remainder of lhs / rhs and assigns it to lhs |
| `/=%`  |  divides lhs by rhs, returns the remainder |
| `%=/`  |  assigns the remainder to lhs, returns the result of the division |
| `&&`   |  logical AND |
| `\|\|` |  logical OR |
| `!`    |  (unary) logical NOT |
| `==`   |  equal to |
| `!=`   |  not equal to |
| `<`    |  less than |
| `>`    |  greater than |
| `<=`   |  less than or equal to |
| `>=`   |  greater than or equal to |

#### The div-mod and mod-div operators
Most of these operators are commonplace and use well known notation. The exception might be the div-mod and mod-div operators, which were added as a small optimizing feature. The BF-algorithm that is implemented to execute a division, calculates the remainder in the process. These operators reflect this fact, and let you collect both results in a single operation.

```javascript
function divModExample()
{
    let x = 42;
    let y = 5;

    let z = (x /=% y);

    // x -> x / y (8) and
    // z -> x % y (2)
}

function modDivExample()
{
    let x = 42;
    let y = 5;

    let z = (x %=/ y);
	
    // x -> x % y (2) and
    // z -> x / y (8)
}
```

### Flow
There are 4 ways to control flow in a BrainFix-program: `if` (-`else`), `switch`, `for` and `while`. Each of these uses similar syntax as to what we're familiar with from other C-like programming languages. Each of the flow-control mechanisms is illustrated in the example below:

```javascript
include "std.bfx"

function main()
{
    let n = scand();
	
    // Print 'xoxoxo...' using a for-loop
    for (let i = 0; i < n; ++i)
    {
        if (i % 2 == 0)
            printc('x');  // defined in the std/io library
        else
            printc('o');
    }
    endl();               // newline (also from std/io)

    // Let n go to zero
    while (n > 0)
    {
        switch (--n)
        {
            case 0:
                 println("Done!");
            case 1:
                 println("Almost done!");
            default:
            {
                prints("Working on it: ");
                printd(n);
                endl();
            }
        }
    }
}
```

#### Preventing Loop Unrolling with `for*` and `while*`
Within a runtime-evaluated loop, the compiler can't make any assumptions about the values of each of the variables, so it has to output BF-algorithms for each of the operations in the body of the loop. Because of this, loops generally yield great amounts of BF code. To reduce the size of the output, the compiler will by default try to unroll each loop (both `for` and `while`) by evaluating the body and condition for as long as it can. When the loop can't be fully unrolled (because the stop-condition can only be known at runtime) or the number of iterations exceeds 50, it will fall back on generating code for executing the loop at runtime.

However, loop-unrolling can take a long time, resulting in long compilation times for loops with large bodies or many iterations. Especially in the latter case, it can take some time before the compiler realizes it shouldn't unroll the loop at all (since it has to evaluate the body 50 times before coming to this conclusion). To indicate to the compiler that it shouldn't attempt to unroll the loop, we can use `for*` and `while*` instead.

```javascript
function main()
{
    // The compiler will try to unroll this, even though we can see
    // that it will take 100 iterations (> 50).
    
    for (let i = 0; i != 100; ++i)
    {
        printd(i);
        endl();
    }

    // Use for* instead: same resulting BF-code, faster compilation
    for* (let i = 0; i != 100; ++i)
    {
        printd(i);
        endl();
    }
}
```

#### Switch Statements
In BrainFix, a `switch` statement is simply a syntactic alternative to an `if-else` ladder. Most compiled languages like C and C++ will generate code that jumps to the appropriate case-label (which therefore has to be constant expression), which in many cases is faster than the equivalent `if-else` ladder. In BrainF*ck, this is difficult to implement due to the lack of jump-instructions. For the same reason, a `break` statement is not required in the body of a case and it's therefore not possible to 'fall through' cases: only one case will ever be executed.

#### No return, break or continue?
BrainF*ck does not contain an opcode that let's us jump to arbitrary places in the code, which makes it very hard to implement `goto`-like features like `return`, `break` and `continue`. Instead, it is up to the programmer to implement conditional blocks using `if`, `if`-`else` or `switch` to emulate these jumps.

### File Inclusion
The compiler accepts only 1 sourcefile, but the `include` keyword can be used to organize your code among different  files. Even though the inner workings are not exactly the same as the C-preprocessor, the semantics pretty much are. When an include directive is encountered, the lexical scanner is simply redirected to that file and continues scanning the original file when it has finished scanning the included one. Currently, circular inclusions are not detected, and will simply crash the compiler.

### Standard Library
The standard library provides some useful functions in two categories: IO and mathematics. Below is a list of provided functions that you can use to make your programs interactive and mathematical. Also, in the "bool.bfx" headerfile, the constants `true` and `false` are defined to `1` and `0` respectively.

#### IO
All functions below are defined in `std/io.bfx`:

|     function     | description  |
| ---------------- | ------------ |
|   `printc(x)`	   | Print `x` as ASCII character |
|   `printd(x)`	   | Print `x` as decimal (at most 3 digits) |
|   `printd_4(x)`  | Print `x` as decimal (at most 4 digits) |
|   `prints(str)`  | Print string (stop at `\0` or end of the string) |
|   `println(str)` | Same as `prints()` but including newline |
|   `print_vec(v)` | Print formatted vector, including newline: `(v1, v2, v3, ..., vN)` |
|   `endl()`	   | Print a newline (same as `printc('\n')`) |
|   `scanc()`	   | Read a single byte from stdin |
|   `scand()`	   | Read at most 3 bytes from stdin and convert to decimal |
|   `scand_4()`	   | Read at most 4 bytes from stdin and convert to decimal |
|   `scans(buf)`   | Read string from stdin. `sizeof(buf)` determines maximum number of bytes to read |
|   `to_int(str)`  | Converts string to int (at most 3 digits) |
|   `to_int_4(str)`  | Converts string to int (at most 4 digits) |
|   `to_string(x)` | Converts int to string (at most 3 digits) |
|   `to_string_4(x)` | Converts int to string (at most 4 digits) |
|   `to_binary_str(x)` | Returns binary representation of `x` as a string |
|   `to_hex_str(x)` | Returns hexadecimal representation of `x` as a string |

##### Big Numbers
On the default architecture, where the cells are only 1 byte long, values can never grow beyond 255. It is therefore sufficient to assume that number will never grow beyond 3 digits. However, when the target architecture contains larger cells, the functions suffixed with `_4` can be used to extend some facilities to 4 digits. Printing and scanning even larger digits is also possible, but functions to this end are not provided by the standard library for the simple reason that these functions would be terribly slow and impractical.

#### Math
All functions below are defined in `std/math.bfx`:

|     function     | description  |
| ---------------- | ------------ |
|   `pow(x,y)`	   | Calculate x raised to the power y |
|   `square(x)`    | Calculate the square of x |
|   `sqrt(x)`	   | Calculate the square root of x, rounded down |
|   `factorial(n)` | Calculate n! (overflows for n > 5) |
|   `min(x,y)`     | Returns the minimum of x and y |
|   `max(x,y)`     | Returns the maximum of x and y |
|   `to_binary_array(x)` | Returns 8-bit binary representation of x as array of 0's and 1's |
|   `from_binary_array(x)` | Takes a binary array and converts it back to 8-bit integer |
|   `bit8_or(x, y)` | Returns bitwise OR of `x` and `y` (8-bit) |
|   `bit8_and(x, y)` | Returns bitwise AND of `x` and `y` (8-bit) |
|   `bit8_xor(x, y)` | Returns bitwise XOR of `x` and `y` (8-bit) |
|   `bit8_shift_left(x, n)` | Shift the binary representation of `x` by `n` bits to the left. |
|   `bit8_shift_right(x, n)` | Shift the binary representation of `x` by `n` bits to the right. |
|   `initRng(s1, s2)` | Initialize the RNG (see below). |
|   `rand()` | Generate random number (see below). |

#### Pseudorandom Numbers
A very simple 8-bit RNG that returns values in the range 0-255 has been implemented in the Standard Library to be used in situations where the statistical properties of the distribution are not very important. Let's face it: you're using BrainFix, so they're probably not. The RNG has to be initialized by calling `initRng(s1, s2)`, where `s1` and `s2` are two seeding values: `s1` should be in the range of 0-255 and `s2` should be in the range of 0-15 (larger values will wrap around, e.g. `s2 = 17` will yield the same sequence of numbers as `s2 = 1`). After initializing the RNG, the `rand()` function may be called repeatedly to generate a sequence of numbers that will visit every number in the range 0-255. A total number of 256 * 16 = 4096 unique sequences can therefore be generated.

It is common to use the system clock to obtain appropriate seed-values. This is of course not possible in BrainFix, because Brainf*ck doesn't allow us to communicate with the system kernel. You should just ask the end-user to input two numbers; every unique combination of numbers will then result in a unique 'experience', if you will.

N.B. Algorithm borrowed from [White Flame](https://codebase64.org/doku.php?id=base:small_fast_8-bit_prng).


```javascript
include "std.bfx"

function main()
{
    println("Enter two numbers (0-255): ");
    let s1 = scand();
    let s2 = scand();

    
    initRng(s1, s2);
    let x = rand() % 10;
    let y = 255;
    let count = 0;
    
    while (x != y)
    {
        println("Enter your guess (0-9): ");
        let y = scand();
        ++count;
    }

    prints("You won!! You only needed ");
    printd(count);
    println(" guesses :)");
}
```


