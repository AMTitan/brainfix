# Brainfix v2.0
This is a reboot of a little project I did as a student. BrainFix is a compiler that takes a C-style
language (with elements taken from other languages or designed to match the needs) and compiles this
into [BrainF*ck](https://en.wikipedia.org/wiki/Brainfuck), an esoteric programming language consisting of only 8 operations.

## Bisonc++ and Flexc++
The lexical scanner and parser that are used to parse the Brainfix language are generated by [Bisonc++](https://fbb-git.gitlab.io/bisoncpp/)
and [Flexc++](https://fbb-git.gitlab.io/flexcpp/) (not to be confused with bison++ and flex++). This software is readily available in the
Debian repositories, but not necessarily needed to build this project. The sourcefiles generated by these programs based on the
current grammar and lexer specifications are included in the source-folder.

## Building
To build the project, simply cd into the src folder and call make:

```
cd src
make
```

To let bisonc++ and flexc++ regenerate the sourcecode for the scanner and parser, do

```
make regenerate
make
```

To run the resulting Brainf*ck code, you can use any third party utility that does the job. However, a simple
interpreter is included in the project, which you can build by running

```
make interpreter
```

## Usage
Building the project results in a executable called `bfx`. It takes either one or two arguments: the path to the
BrainFix file (usually .bfx) and an optional second path to the output file containing the generated BrainF*ck (usually .bf). When only one argument is provided, the BF output will be directed to stdout.

```
./bfx path/to/file.bfx path/to/output.bf
./bfx path/to/file.bfx > output.bf
```

To run the resulting BF, call the included interpreter or any other utility that was designed to run or compile
BF. The included interpreter takes 2 arguments: the size of the machine (number of bytes, canonically at least 30000)
and the input-file. For example:

```
./bfint 30000 output.bf
```

### Example: Hello World
Every programming language tutorial starts with a "Hello, World!" program of some sort. This is no exception:

```javascript
// File: hello.bfx
include "std/io.bfx"

function main()
{
    println("Hello, World!");
}
```

The program starts with an end-of-line comment (C-comment blocks between `/*` and `*/` are also allowed) and then
includes the IO-library which is included with this project. This exposes some basic IO-facilities the sourcefile.

Next, the main-function is defined. Every valid BFX-program should contain a `main` function which takes no arguments
and does not return anything. The order in which the functions are defined in a BFX-file does not matter; the compiler
will always try to find main and use this as the entrypoint.

In `main()`, the function `println()` from the IO library is called to print the argument and a newline to the console.
Let's try:

```
$ ./bfx hello.bfx hello.bf
$ ./bfint 30000 hello.bf
$ Hello, World!
$
```

## Language
### Functions
A BrainFix program consists of a series of functions (one of which is called `main()`). Apart from global variable declarations, `const` declarations and file inclusion (more on those later), no other syntax is allowed at global scope. In other words: BF code is only generated in function-bodies.

A function without a return-value is defined like we saw in the Hello World example and may take any number of parameters:
```javascript
function [functionName]([param1], ... [paramN])
{
    // body
}
```

When a function has a return-value, it is defined as follows:
```javascript
function [returnVariable] = [functionName]([param1], ..., [paramN])
{
    // body --> must contain instantiation of [returnVariable]!
}
```

It does not matter where a function is defined with respect to the call:
```javascript
function foo()
{
    x = 31;
    y = 38;

    nice = bar(x, y); // works, even if bar is defined below
}

function z = bar(x, y)
{
    z = x + y; // return variable is instantiated here
}
```

### Operators
The following operators are supported by BrainFix:

| Operator | Description |
| --- | --- |
| `++`  |  post- and pre-increment |
| `--`   |  post- and pre-decrement |
| `+`    |  add |
| `-`    |  subtract |
| `*`    |  multiply |
| `/`    |  divide |
| `%`    |  modulo |
| `+=`   |  add to left-hand-side (lhs), returns lhs |
| `-=`   |  subtract from lhs, returns lhs |
| `*=`   |  multiply lhs by rhs, returns lhs |
| `/=`   |  divide lhs by rhs, returns lhs |
| `%=`   |  assigns the remainder of lhs / rhs and assigns it to lhs |
| `/=%`  |  divides lhs by rhs, returns the remainder |
| `%=/`  |  assignes the remainder to lhs, returns the result of the division |
| `&&`   |  logical AND |
| `\|\|` |  logical OR |
| `!`    |  (unary) logical NOT |
| `==`   |  equal to |
| `!=`   |  not equal to |
| `<`    |  less than |
| `>`    |  greater than |
| `<=`   |  less than or equal to |
| `>=`   |  greater than or equal to |

#### The div-mod and mod-div operators
Most of these operators are commonplace and use well known notation. The exception might be the div-mod and mod-div operators, which were added as a small optimizing feature. The BF-algorithm that is implemented to execute a division, calculates the remainder in the process. These operators reflect this fact, and let you collect both results in a single operation.

```javascript
function divModExample()
{
    x = 42;
    y = 5;

    z = (x /=% y);

    // x -> x / y (8) and
    // z -> x % y (2)
}

function modDivExample()
{
    x = 42;
    y = 5;

    z = (x %=/ y);
	
    // x -> x % y (2) and
    // z -> x / y (8)
}
```

